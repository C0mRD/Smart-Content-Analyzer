// manifest.json
{
  "manifest_version": 3,
  "name": "Web Scraper Extension",
  "version": "1.0",
  "description": "Extract structured data from web pages",
  "permissions": ["activeTab", "storage", "scripting", "downloads"],
  "action": {
    "default_popup": "popup.html"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "background": {
    "service_worker": "background.js"
  }
}

// background.js
chrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {
  if (message.action === "downloadData") {
    const recipes = message.recipes;

    // Get the active tab
    const [tab] = await chrome.tabs.query({
      active: true,
      currentWindow: true,
    });

    // Extract data for each recipe
    const results = await chrome.scripting.executeScript({
      target: { tabId: tab.id },
      func: (selectors) => {
        return selectors.map((selector) => {
          const elements = document.querySelectorAll(selector);
          return Array.from(elements).map((el) => el.textContent.trim());
        });
      },
      args: [
        recipes
          .map((recipe) => recipe.attributes.map((attr) => attr.selector))
          .flat(),
      ],
    });

    const extractedData = results[0].result;

    // Format data for CSV
    let csvContent = "data:text/csv;charset=utf-8,";

    // Add headers
    const headers = recipes
      .map((recipe) => recipe.attributes.map((attr) => attr.name))
      .flat();
    csvContent += headers.join(",") + "\n";

    // Add data rows
    const maxRows = Math.max(...extractedData.map((col) => col.length));
    for (let i = 0; i < maxRows; i++) {
      const row = extractedData.map((col) => col[i] || "");
      csvContent +=
        row.map((cell) => `"${cell.replace(/"/g, '""')}"`).join(",") + "\n";
    }

    // Create download link
    const encodedUri = encodeURI(csvContent);
    chrome.downloads.download({
      url: encodedUri,
      filename: "scraped_data.csv",
    });
  }
  return true;
});


// content.js
let selectedElements = [];
let highlightedElement = null;
let isActive = true;
let isSelectingAttribute = false;

// Add selection overlay
const overlay = document.createElement("div");
overlay.style.cssText = `
  position: fixed;
  pointer-events: none;
  border: 2px solid #4CAF50;
  background: rgba(76, 175, 80, 0.1);
  z-index: 10000;
  display: none;
`;
document.body.appendChild(overlay);

function updateOverlay(element) {
  if (!element) {
    overlay.style.display = "none";
    return;
  }

  const rect = element.getBoundingClientRect();
  overlay.style.display = "block";
  overlay.style.top = rect.top + window.scrollY + "px";
  overlay.style.left = rect.left + window.scrollX + "px";
  overlay.style.width = rect.width + "px";
  overlay.style.height = rect.height + "px";
}

function handleMouseMove(event) {
  if (!isActive || !isSelectingAttribute) return;

  if (highlightedElement !== event.target) {
    highlightedElement = event.target;
    updateOverlay(highlightedElement);
  }
}

function handleClick(event) {
  if (!isActive || !isSelectingAttribute) return;

  event.preventDefault();
  event.stopPropagation();

  const selector = getUniqueSelector(event.target);
  chrome.runtime.sendMessage({
    action: "elementSelected",
    selector: selector,
    text: event.target.textContent.trim(),
  });

  // Store selection state in storage
  chrome.storage.local.set({
    lastSelection: {
      selector: selector,
      text: event.target.textContent.trim(),
    },
  });

  isSelectingAttribute = false;
  updateOverlay(null);
}

function getUniqueSelector(element) {
  const path = [];
  while (element && element.nodeType === Node.ELEMENT_NODE) {
    let selector = element.tagName.toLowerCase();

    if (element.id) {
      selector = "#" + element.id;
      path.unshift(selector);
      break;
    }

    if (element.className) {
      const classes = Array.from(element.classList)
        .filter((c) => !c.startsWith("_")) // Filter out dynamic classes
        .join(".");
      if (classes) {
        selector += "." + classes;
      }
    }

    let sibling = element;
    let nth = 1;
    while ((sibling = sibling.previousElementSibling)) {
      if (sibling.tagName === element.tagName) nth++;
    }

    if (nth > 1) selector += `:nth-of-type(${nth})`;

    path.unshift(selector);
    element = element.parentElement;
  }

  return path.join(" > ");
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "toggleState") {
    isActive = message.isActive;
    if (!isActive) {
      isSelectingAttribute = false;
      updateOverlay(null);
    }
  } else if (message.action === "startSelection") {
    isSelectingAttribute = true;
    // Store selection state
    chrome.storage.local.set({ isSelectingAttribute: true });
  } else if (message.action === "stopSelection") {
    isSelectingAttribute = false;
    updateOverlay(null);
    // Clear selection state
    chrome.storage.local.remove(["isSelectingAttribute", "lastSelection"]);
  }
  sendResponse({ status: "received" });
  return true;
});

// Restore selection state on page load
chrome.storage.local.get(["isSelectingAttribute"], function (result) {
  isSelectingAttribute = result.isSelectingAttribute || false;
});

document.addEventListener("mousemove", handleMouseMove);
document.addEventListener("click", handleClick);

// popup.js
// popup.js
document.addEventListener("DOMContentLoaded", function () {
  // Get DOM elements
  const toggleButton = document.getElementById("toggleButton");
  const toggleStatus = document.getElementById("toggleStatus");
  const recipeListDiv = document.getElementById("recipes");
  const dataTable = document.getElementById("data-table");
  const saveExcelButton = document.getElementById("save-excel");
  const addRecipeButton = document.getElementById("add-recipe-button");
  const selectionModeDiv = document.getElementById("selection-mode");

  // State variables
  let recipes = [];
  let currentRecipeIndex = null;

  // Function definitions
  function updateToggleStatus(isActive) {
    if (toggleStatus) {
      toggleStatus.textContent = isActive ? "Active" : "Inactive";
    }
  }

  function renderRecipes() {
    recipeListDiv.innerHTML = "";
    recipes.forEach((recipe, recipeIndex) => {
      const recipeDiv = document.createElement("div");
      recipeDiv.className = "recipe";

      const recipeTitle = document.createElement("h3");
      recipeTitle.textContent = recipe.name;
      recipeDiv.appendChild(recipeTitle);

      const addAttrButton = document.createElement("button");
      addAttrButton.textContent = "Add Attribute";
      addAttrButton.addEventListener("click", () =>
        startAttributeSelection(recipeIndex),
      );
      recipeDiv.appendChild(addAttrButton);

      recipe.attributes.forEach((attr, attrIndex) => {
        const attrDiv = document.createElement("div");
        attrDiv.className = "attribute";

        const attrText = document.createElement("span");
        attrText.textContent = attr.name;
        attrDiv.appendChild(attrText);

        const deleteButton = document.createElement("button");
        deleteButton.textContent = "Delete";
        deleteButton.addEventListener("click", () =>
          deleteAttribute(recipeIndex, attrIndex),
        );
        attrDiv.appendChild(deleteButton);

        recipeDiv.appendChild(attrDiv);
      });

      recipeListDiv.appendChild(recipeDiv);
    });
  }

  function startAttributeSelection(recipeIndex) {
    currentRecipeIndex = recipeIndex;
    selectionModeDiv.classList.add("active");
    chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
      if (tabs[0]) {
        chrome.tabs
          .sendMessage(tabs[0].id, { action: "startSelection" })
          .catch((error) => {
            console.error("Error sending message to content script:", error);
          });
      }
    });
    // Store selection state
    chrome.storage.local.set({
      isSelectingAttribute: true,
      currentRecipeIndex: recipeIndex,
    });
  }

  function deleteAttribute(recipeIndex, attrIndex) {
    if (recipes[recipeIndex] && recipes[recipeIndex].attributes) {
      recipes[recipeIndex].attributes.splice(attrIndex, 1);
      renderRecipes();
      extractDataForPreview(recipeIndex);
      // Save updated recipes
      chrome.storage.local.set({ recipes: recipes });
    }
  }

  async function extractDataForPreview(recipeIndex) {
    if (!recipes[recipeIndex]) return;

    const recipe = recipes[recipeIndex];

    try {
      const [tab] = await chrome.tabs.query({
        active: true,
        currentWindow: true,
      });
      if (!tab) return;

      const result = await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        func: (selectors) => {
          return selectors.map((selector) => {
            try {
              const elements = document.querySelectorAll(selector);
              return Array.from(elements).map((el) => el.textContent.trim());
            } catch (error) {
              console.error(
                `Error selecting elements with selector ${selector}:`,
                error,
              );
              return [];
            }
          });
        },
        args: [recipe.attributes.map((attr) => attr.selector)],
      });

      if (!result || !result[0] || !result[0].result) return;

      const extractedData = result[0].result;
      const tableData = [];
      const headers = recipe.attributes.map((attr) => attr.name);
      tableData.push(headers);

      const maxRows = Math.max(...extractedData.map((col) => col.length));
      for (let i = 0; i < Math.min(maxRows, 3); i++) {
        const row = extractedData.map((col) => col[i] || "");
        tableData.push(row);
      }

      updateDataPreview(tableData);
    } catch (error) {
      console.error("Error extracting data:", error);
    }
  }

  function updateDataPreview(tableData) {
    if (!dataTable) return;

    dataTable.innerHTML = "";
    tableData.forEach((row, index) => {
      const tr = document.createElement("tr");
      row.forEach((cell) => {
        const td = document.createElement(index === 0 ? "th" : "td");
        td.textContent = cell || "";
        tr.appendChild(td);
      });
      dataTable.appendChild(tr);
    });
  }

  function processElementSelection(selection) {
    if (currentRecipeIndex === null) return;

    const attrName = prompt(
      "Enter attribute name for selected element:",
      selection.text ? selection.text.substring(0, 30) : "",
    );

    if (attrName) {
      if (!recipes[currentRecipeIndex].attributes) {
        recipes[currentRecipeIndex].attributes = [];
      }

      recipes[currentRecipeIndex].attributes.push({
        name: attrName,
        selector: selection.selector,
      });

      renderRecipes();
      extractDataForPreview(currentRecipeIndex);

      // Clear selection state
      chrome.storage.local.remove(["isSelectingAttribute", "lastSelection"]);
      selectionModeDiv.classList.remove("active");

      // Stop selection mode in content script
      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
        if (tabs[0]) {
          chrome.tabs
            .sendMessage(tabs[0].id, { action: "stopSelection" })
            .catch((error) => {
              console.error("Error sending stop selection message:", error);
            });
        }
      });

      // Save updated recipes
      chrome.storage.local.set({
        recipes: recipes,
        currentRecipeIndex: null,
      });

      currentRecipeIndex = null;
    }
  }

  // Initialize state
  chrome.storage.local.get(
    [
      "isActive",
      "recipes",
      "isSelectingAttribute",
      "lastSelection",
      "currentRecipeIndex",
    ],
    function (result) {
      const isActive = result.isActive !== undefined ? result.isActive : true;
      toggleButton.checked = isActive;
      updateToggleStatus(isActive);

      if (result.recipes) {
        recipes = result.recipes;
        renderRecipes();
      }

      if (result.currentRecipeIndex !== undefined) {
        currentRecipeIndex = result.currentRecipeIndex;
      }

      if (result.isSelectingAttribute) {
        selectionModeDiv.classList.add("active");
        if (result.lastSelection) {
          processElementSelection(result.lastSelection);
        }
      }
    },
  );

  // Event Listeners
  toggleButton.addEventListener("change", function () {
    const isActive = toggleButton.checked;
    chrome.storage.local.set({ isActive: isActive }, function () {
      updateToggleStatus(isActive);
      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
        if (tabs[0]) {
          chrome.tabs
            .sendMessage(tabs[0].id, {
              action: "toggleState",
              isActive: isActive,
            })
            .catch((error) => {
              console.error("Error sending toggle state:", error);
            });
        }
      });
    });
  });

  addRecipeButton.addEventListener("click", function () {
    const recipeName = prompt("Enter recipe name:");
    if (recipeName) {
      const recipe = { name: recipeName, attributes: [] };
      recipes.push(recipe);
      renderRecipes();
      // Save updated recipes
      chrome.storage.local.set({ recipes: recipes });
    }
  });

  saveExcelButton.addEventListener("click", function () {
    chrome.runtime.sendMessage({
      action: "downloadData",
      recipes: recipes,
    });
  });

  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "elementSelected") {
      processElementSelection(message);
    }
    return true;
  });

  // Save state before popup closes
  window.addEventListener("beforeunload", function () {
    chrome.storage.local.set({
      recipes: recipes,
      currentRecipeIndex: currentRecipeIndex,
    });
  });
});


// popup.html
<!doctype html>
<html>
    <head>
        <title>Web Scraper</title>
        <style>
            body {
                width: 400px;
                padding: 10px;
                font-family: Arial, sans-serif;
            }
            .recipe {
                border: 1px solid #ccc;
                margin: 10px 0;
                padding: 10px;
            }
            .attribute {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin: 5px 0;
                padding: 5px;
                background: #f5f5f5;
            }
            button {
                margin: 5px;
                padding: 5px 10px;
                cursor: pointer;
            }
            button:disabled {
                cursor: not-allowed;
                opacity: 0.6;
            }
            .selection-mode {
                background: #ffeb3b;
                padding: 10px;
                margin: 10px 0;
                display: none;
            }
            .selection-mode.active {
                display: block;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
            }
            th,
            td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #f2f2f2;
            }
            .toggle-container {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }
            #toggleStatus {
                margin-left: 10px;
            }
        </style>
    </head>
    <body>
        <div class="toggle-container">
            <input type="checkbox" id="toggleButton" />
            <span id="toggleStatus">Active</span>
        </div>
        <div id="selection-mode" class="selection-mode">
            Selection Mode Active: Click an element on the page
        </div>
        <button id="add-recipe-button">Add Recipe</button>
        <div id="recipes"></div>
        <table id="data-table"></table>
        <button id="save-excel">Save as Excel</button>
        <script src="popup.js"></script>
    </body>
</html>


Instruction: The code is working. Just need one feature After clicking add attribute when in selection mode. I am clicking on the component if it's a hyperlink it redirecting to a new page. Then I have to go back do add the attribute. So please disable hyperlink and redirection when in selection mode. Everything else is fine.
